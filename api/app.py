import os
import re

from flask import Flask, request, jsonify
from flask_cors import CORS
from supabase import create_client, Client
from dotenv import load_dotenv
import numpy as np
from google import genai
import gemini_utils

load_dotenv()

app = Flask(__name__)
CORS(app)

supabase: Client = create_client(
    os.environ.get("SUPABASE_URL"),
    os.environ.get("SUPABASE_KEY")
)

# gemini_client is now handled in gemini_utils

# --- helpers ---

STRUCTURED_FIELDS = {"name", "description", "phone_number", "email"}

def bad_request(message: str, details: dict | None = None, status_code: int = 400):
    payload = {"error": message}
    if details:
        payload["details"] = details
    return jsonify(payload), status_code

def get_json_body_required():
    data = request.get_json(silent=True)
    if data is None:
        return None, bad_request("Expected JSON body with Content-Type: application/json")
    if not isinstance(data, dict):
        return None, bad_request("JSON body must be an object (key/value map)")
    return data, None

def normalize_text(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip()).lower()

def get_text_blob_from_request() -> tuple[str | None, tuple | None]:
    """
    Accepts either:
      - Content-Type: application/json with {"text": "..."}
      - raw text/plain (or anything else) as the request body
    """
    body_json = request.get_json(silent=True)
    if isinstance(body_json, dict) and "text" in body_json:
        text = body_json.get("text")
        if not isinstance(text, str) or not text.strip():
            return None, bad_request("Field 'text' must be a non-empty string")
        return text, None

    raw = request.get_data(as_text=True)
    if not raw or not raw.strip():
        return None, bad_request("Send a non-empty text body or JSON {'text': '...'}")
    return raw, None

# --- routes ---

@app.route("/health")
def index():
    try:
        supabase.table("foodbanks").select("*").limit(1).execute()
        supabase_connected = True
    except Exception:
        supabase_connected = False
    
    gemini_connected = gemini_utils.check_gemini_health()
    
    return jsonify({
        "UP": supabase_connected and gemini_connected,
        "services": {
            "supabase_connected": supabase_connected,
            "gemini_connected": gemini_connected}
        }), 200 if supabase_connected and gemini_connected else 503


@app.route("/foodbanks/<int:foodbank_id>")
def foodbank(foodbank_id: int):
    response = (
        supabase
        .from_("foodbanks")
        .select("*")
        .eq("id", foodbank_id)
        .execute()
    )
    if not response.data:
        return bad_request("Foodbank not found", {"id": foodbank_id}, status_code=404)
    return jsonify(response.data[0])


@app.route("/foodbanks", methods=["POST"])
def create_foodbank_structured():
    """
    Structured creation endpoint:
    - Accepts: name, description, phone_number, email
    - Rejects: uploaded_data (must not be provided here)
    - Inserts a new row; id is generated by DB identity
    """
    body, err = get_json_body_required()
    if err:
        return err

    if "uploaded_data" in body:
        return bad_request(
            "Do not send 'uploaded_data' to this endpoint. Use /foodbanks/<id>/uploaded-data instead."
        )

    allowed = {k: body.get(k) for k in STRUCTURED_FIELDS if k in body}
    if not allowed:
        return bad_request(
            "No structured fields provided",
            {"allowed_fields": sorted(STRUCTURED_FIELDS)}
        )

    response = (
        supabase
        .from_("foodbanks")
        .insert(allowed)
        .execute()
    )
    return jsonify(response.data), 201


@app.route("/foodbanks", methods=["GET"])
def list_foodbanks():
    response = (
        supabase
        .from_("foodbanks")
        .select("*")
        .execute()
    )
    return jsonify(response.data)


@app.route("/foodbanks/<int:foodbank_id>", methods=["POST"])
def update_foodbank_data(foodbank_id: int):
    """
    Updates the 'uploaded_data' field for a food bank.
    """
    # Check if foodbank exists first
    check = supabase.from_("foodbanks").select("id").eq("id", foodbank_id).execute()
    if not check.data:
        return bad_request("Foodbank not found", {"id": foodbank_id}, status_code=404)

    text_blob, err = get_text_blob_from_request()
    if err:
        return err

    # Store the raw text in 'uploaded_data' (represented as JSON or just a string/object)
    # The schema says jsonb, so we'll store it as an object with a 'text' key or similar
    update_data = {"uploaded_data": {"raw_text": text_blob}}

    response = (
        supabase
        .from_("foodbanks")
        .update(update_data)
        .eq("id", foodbank_id)
        .execute()
    )
    return jsonify(response.data)


@app.route("/find_recommendations", methods=["POST"])
def find_recommendations():
    """
    Receives a donor's prompt and matches it against all food banks
    using Gemini to provide alignment scores and rationales.
    """
    text_blob, err = get_text_blob_from_request()
    if err:
        return err

    # Fetch all food banks to provide context to Gemini
    response = (
        supabase
        .from_("foodbanks")
        .select("id, name, description, uploaded_data")
        .execute()
    )

    foodbanks = response.data or []
    if not foodbanks:
        return jsonify({
            "recommendation_reason": "No food banks found in the database.",
            "recommendations": []
        }), 200

    # Get scores from Gemini
    match_response = gemini_utils.get_alignment_scores(text_blob, foodbanks)

    # Map the scores back to the food bank objects
    mapping = {m.foodbank_id: m for m in match_response.matches}
    
    enriched = []
    for row in foodbanks:
        match = mapping.get(row["id"])
        if match:
            # We don't want to leak 'uploaded_data' to the frontend usually, 
            # or at least clean it up
            row_out = {
                "id": row["id"],
                "name": row["name"],
                "description": row["description"],
                "match_score": match.score * 10, # Convert 1-10 to 1-100 for frontend consistency
                "match_reason": match.reasoning
            }
            enriched.append(row_out)

    return jsonify({
        "recommendation_reason": match_response.overall_summary,
        "recommendations": enriched
    }), 200


@app.route("/foodbanks/<int:foodbank_id>/summary", methods=["GET"])
def get_foodbank_summary(foodbank_id: int):
    """
    Generates an AI summary of inventory and needs for a specific food bank.
    """
    # Fetch foodbank data
    response = (
        supabase
        .from_("foodbanks")
        .select("uploaded_data")
        .eq("id", foodbank_id)
        .execute()
    )
    
    if not response.data:
        return bad_request("Foodbank not found", status_code=404)
        
    data = response.data[0]
    uploaded_data = data.get("uploaded_data") or {}
    raw_text = uploaded_data.get("raw_text", "")
    
    if not raw_text:
        return jsonify({
            "inventory_summary": "No data available.",
            "needs_summary": "No data available."
        })

    # Generate summary with Gemini
    summary = gemini_utils.generate_foodbank_summary(raw_text)
    
    return jsonify(summary.model_dump())



if __name__ == "__main__":
    app.run(debug=True)
